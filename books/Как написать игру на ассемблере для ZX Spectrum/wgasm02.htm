<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
   <META NAME="Author" CONTENT="Alex">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (Win95; I) [Netscape]">
   <META NAME="KEYWORDS" CONTENT="zx, spectrum, speccy, sinclair, z80, assembler">
   <TITLE>Как написать игру для ZX Spectrum на ассемблере - ГЛАВА 2</TITLE>
</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000FF" VLINK="#FF0000" ALINK="#000066">

<BASEFONT SIZE=3>

<h2><center><a name="n00">ГЛАВА ВТОРАЯ,</a></center></h2>
<center><b>из которой вы узнаете о том, что же такое ассемблер и чем он отличается от Бейсика и машинных кодов, а также усвоите некоторые основные понятия</b></center>
<p><br><br>
Прежде чем приступать к изучению ассемблера, нужно усвоить несколько новых терминов, чтобы понимать, о чем вообще идет речь. Эту главу можно считать введением в совершенно новый для вас язык программирования (если же вы знакомы хотя бы с азами ассемблера, то можете лишь бегло пролистать эту и следующую главы, ибо они предназначены, в первую очередь, для новичков, делающих первые шаги в изучении машинного языка).
<p><br>
<h3><a name="n01">МАШИННЫЕ КОДЫ И АССЕМБЛЕР</a></h3>
<hr>
Вы уже, вероятно, имеете некоторое представление о том, что такое машинные коды, а если нет, то мы сейчас постараемся объяснить это, хотя бы немного, что называется, &laquo;на пальцах&raquo;, не вдаваясь в теорию проектирования компьютерной техники.
<p>
Нетрудно догадаться, что микропроцессор, будучи куском железа, пусть даже довольно интеллектуального, но все же железа, не способен понимать слова человеческого языка, а тем более&nbsp;- складывать отдельные слова в осмысленные фразы. Как и всякая порядочная электронная машина, он может воспринимать только электрические заряды. Но в отличие от пылесоса микропроцессор принимает заряды одновременно с восьми контактов (строго говоря, микропроцессор обрабатывает гораздо больше сигналов, но сейчас нас интересуют только восемь из них) и в зависимости от поступившего сигнала выполняет то или иное действие.
<p>
У каждого из этих восьми контактов может быть лишь два состояния&nbsp;- есть заряд или нет заряда. Поэтому его наличие можно представить как&nbsp;1, а отсутствие&nbsp;- как&nbsp;0. Последовательности из единиц и нулей дают числа в двоичном представлении, но их несложно перевести в привычный десятичный формат. Напомним, как это делается на примере числа 00111100. Самый младший разряд (то есть, крайнюю правую цифру) умножаем на&nbsp;1, второй разряд&nbsp;- на&nbsp;2, третий&nbsp;- на&nbsp;4, следующий&nbsp;- на&nbsp;8 и так далее. Иными словами, значение каждого разряда умножается на&nbsp;2 в степени n, где n&nbsp;- номер разряда, который может изменяться от&nbsp;0 до&nbsp;7 (то есть, говоря научно, 2&nbsp;- это основание системы счисления). Если вам не очень понятно такое определение, воспользуйтесь простой формулой для перевода нашего двоичного числа в десятичное:
<pre>
00111100=0<font face="symbol">ґ</font>128+0<font face="symbol">ґ</font>64+1<font face="symbol">ґ</font>32+1<font face="symbol">ґ</font>16+1<font face="symbol">ґ</font>8+1<font face="symbol">ґ</font>4+0<font face="symbol">ґ</font>2+0<font face="symbol">ґ</font>1=60
</pre>
Точно так же можно перевести в десятичное и любое другое число, представленное в двоичном формате. Попутно напомним, что разряды двоичных чисел в информатике принято называть битами, а последовательности из 8&nbsp;битов составляют байты.
<p>
Теперь вы вправе спросить, а что же будет, если микропроцессору дать такую команду? В&nbsp;ответ мы напишем похожую строку на хорошо известном вам Бейсике:
<pre>
LET A=A+1
</pre>
то есть содержимое переменной A увеличивается на единицу. И&nbsp;если последнюю запись понять не так уж трудно, то на свете найдется не так уж много людей, способных не только воспринимать, но и писать достаточно сложные программы, оперируя голыми числами, да еще двоичными. Простой и логичный выход из создавшегося затруднения&nbsp;- заменить все коды машинного языка человеческими словами или, хотя бы сокращениями, поставив каждой команде микропроцессора в соответствие единственное обозначение. Именно такой язык и был назван ассемблером. Он стоит всего лишь на одну ступеньку выше машинных кодов, однако общаться с компьютером на таком языке несравненно проще, чем на языке цифр. Приведенная выше комбинация единиц и нулей 00111100 на ассемблере будет выглядеть так:
<pre>
       INC   A
</pre>
где INC&nbsp;- сокращение от английского слова increase (увеличиваться). Сразу же скажем, что сокращенные имена команд микропроцессора называют <i>мнемониками</i>. Запомните это слово хорошенько, так как оно не раз встретится в нашей книге.
<p><br>
<h3><a name="n02">ЧТО МОЖЕТ МИКРОПРОЦЕССОР Z80?</a></h3>
<hr>
Поскольку ассемблер непосредственно связан с машинными командами, то начинать его изучение будет резонно с вопроса &laquo;а что же может микропроцессор?&raquo; Так вот, если вы считаете, что он способен играть музыку, рисовать картинки или печатать текст, то глубоко заблуждаетесь. Ничего такого микропроцессор не умеет. Он может выполнять лишь самые элементарные действия вроде &laquo;2&nbsp;+&nbsp;2&raquo;, а более сложным, таким как &laquo;2&nbsp;<font face="symbol">ґ</font>&nbsp;2&raquo;, его еще нужно научить. В&nbsp;этом и состоит задача программиста. Но у микропроцессора есть одно преимущество&nbsp;- за одну секунду он способен выполнить многие тысячи операций, поэтому в реальном времени он и кажется достаточно одаренным.
<p>
Вот краткий и не совсем полный список операций, доступных микропроцессору:
<ul>
<li>простейшие арифметические действия сложения и вычитания;</li>
<li>операции с памятью, такие как запись в определенную ячейку или считывание из памяти чисел (подобно <tt>POKE</tt> и <tt>PEEK</tt> в Бейсике);</li>
<li>связь с внешними устройствами через порты (то, чем занимаются в Бейсике <tt>OUT</tt> и <tt>IN</tt>);</li>
<li>обработка отдельных битов (разрядов двоичных чисел) (напомним, что в Бейсике можно задавать битовые константы с помощью ключевого слова <tt>BIN</tt>);</li>
<li>логические операции с двоичными числами;</li>
<li>различные вызовы других подпрограмм;</li>
<li>условные и безусловные переходы;</li>
<li>работа с прерываниями (это средство, совершенно недоступное Spectrum Бейсику, будет обсуждаться в отдельной главе).</li>
</ul>
Вам может показаться странным, что компьютер, располагая столь незначительными средствами, умудряется создавать на экране целые миры, исполнять сложные музыкальные произведения и даже управлять какими-то механизмами вроде принтера. Чтобы прояснить, как это получается, приведем маленький примерчик на Бейсике, построенный по тому же принципу, что и большинство программ в машинных кодах:
<pre>
10 LET ADDR1=16384
20 LET ADDR2=15880
30 LET N=8
40 LET A=PEEK (ADDR2)
50 POKE (ADDR1),A
60 LET ADDR1=ADDR1+256
70 LET ADDR2=ADDR2+1
80 LET N=N-1
90 IF N&lt;&gt;0 THEN GO TO 40
</pre>
Выполнив эту программку, вы увидите в верхнем левом углу экрана букву <b>A</b>. Наверное, нет большой необходимости подробно расписывать, как работает приведенный пример, тем не менее, кратко поясним, что же здесь происходит.
<p>
В переменную <b>ADDR1</b> помещаем адрес (напоминаем, что адресом называется порядковый номер байта в памяти; в&nbsp;ZX&nbsp;Spectrum адреса имеют номера от&nbsp;0 до&nbsp;65535) начала экранной области памяти, а переменная <b>ADDR2</b> указывает на начало данных, находящихся в ПЗУ и описывающих внешний вид символа <b>A</b>. В&nbsp;данном примере адрес <b>ADDR2</b> рассчитан заранее, хотя обычно все вычисления возлагаются на программу. Далее в цикле последовательно считываются 8 байтов, составляющих символ, и переносятся на экран. При этом переменная <b>ADDR1</b> изменяется с шагом&nbsp;256, что обеспечивает заполнение одного знакоместа (чуть позже мы подробно остановимся на строении экрана и методах вычисления его адресов, а пока примите это как данность). Обратите внимание на способ организации цикла в этом примере. С&nbsp;точки зрения Бейсика вся эта программка выглядит довольно неказисто, но зато она довольно точно отражает последовательность действий микропроцессора при выполнении аналогичной задачи.
<p>
Вообще-то все на самом деле выглядит несколько сложнее, а здесь мы продемонстрировали лишь принцип работы одного из самых популярных операторов Бейсика&nbsp;- оператора <tt>PRINT</tt>. Но пусть вас это не пугает, ведь процедура вывода символов на экран уже имеется в компьютере, и совершенно не обязательно воспроизводить ее еще раз в своей собственной программе. Достаточно знать, как ее можно вызвать&nbsp;- и значительная часть проблем отойдет в сторону.
<p>
Однако, не будем забегать вперед, а прежде разберемся до конца с темой этой главы.
<p><br>
<h3><a name="n03">ПРЕИМУЩЕСТВА И НЕДОСТАТКИ ЯЗЫКА АССЕМБЛЕРА</a></h3>
<hr>
Бейсик, Паскаль, Си и подобные им языки относятся к так называемым языкам высокого уровня. Это означает, что операторы, составляющие их словарный запас, по сути своей являются целыми программами, написанными, как правило, на языке низкого уровня&nbsp;- на изучаемом нами ассемблере, а по сути, в машинных кодах, которыми &laquo;говорит&raquo; компьютер. Что касается ассемблера, то он дает возможность писать программы на среднем или низком уровне (точнее, почти на самом низком, как мы уже говорили). Разница между средним и низким уровнем достаточно условная и заключается в том, что первый в полную силу использует возможности операционной системы, обращаясь к готовым подпрограммам, &laquo;зашитым&raquo; в ПЗУ, а второй&nbsp;- нет. Выбор уровня зависит от целей программиста, у каждого из них есть свои преимущества и недостатки, а весь этот разговор мы затеяли лишь затем, чтобы помочь вам сориентироваться в таком выборе.
<p>
Итак, что же мы теряем и что приобретаем с переходом к более низким уровням программирования?
<p>
Преимущества:
<ul>
<li>значительное увеличение скорости выполнения программ;</li>
<li>большая гибкость (отсутствуют рамки Бейсика, независимость от операционной системы, более оптимально используются возможности компьютера);</li>
<li>полученные программы занимают меньше памяти.</li>
</ul>
Недостатки:
<ul>
<li>программы требуют больше времени и внимательности при написании;</li>
<li>сложность отладки (отсутствуют привычные сообщения об ошибках, текст трудно читать);</li>
<li>трудно выполнять арифметические действия (микропроцессор не может обрабатывать дробные числа, да и применение целых чисел имеет ряд ограничений).</li>
</ul>
Чтобы понять, почему программы, написанные на ассемблере, обычно работают во много раз быстрее, давайте посмотрим, какими методами пользуются интерпретаторы (например, тот же Бейсик) и компиляторы.
<p>
Метод, используемый интерпретаторами можно сравнить с переводом со словарем. Микропроцессор последовательно считывает текст программы слово за словом, оператор за оператором, затем лезет в специальную таблицу, содержащую имена команд и адреса подпрограмм, выполняющих заданное действие. И&nbsp;только после того, как весь оператор прочитан до конца, начинается его исполнение. Не увеличивает скорость перевода еще и то, что у компьютера весьма &laquo;короткая память&raquo;, и надо за каждым словом вновь и вновь лезть в словарь, даже если это слово только что встречалось.
<p>
Несколько быстрее работают компиляторы. Полученные с их помощью программы можно сравнить с подстрочником, составленным довольно неумелым переводчиком, поэтому микропроцессору над каждой фразой приходится еще поломать голову, что же хотел сказать этим автор. (Если быть более точным, компилятор каждую фразу исходного языка заменяет кусочком машинного кода, а то, как эффективно он это делает, зависит от авторов данного компилятора&nbsp;- <i>Примеч. ред.</i>) Кроме того, большинство компиляторов имеет дурную привычку &laquo;навешивать&raquo; на программу воз и маленькую тележку совершенно никому не нужного хлама, что при 48K максимальной свободной памяти кажется, мягко говоря, несколько расточительным.
<p>
Что же касается машинных кодов, то это родной язык компьютера, и совершенно естественно, что программу на таком языке микропроцессор может выполнить в самые кратчайшие сроки&nbsp;- ведь в этом случае не приходится прибегать к услугам переводчиков. Безусловно, и тут при желании можно &laquo;загнуть&raquo; такую заумную фразу, которая надолго оставит компьютер в недоумении, но это уже будет на совести автора программы.
<p>
Конечно, умение писать на ассемблере не означает полный отказ от Бейсика и других языков высокого уровня, особенно на первых порах. Поэтому мы ставим цель прежде всего научить вас создавать коротенькие фрагменты, позволяющие значительно обогатить игры и придать им динамичность. Большинство предлагаемых в этой книге подпрограмм построено по принципу широкоизвестного набора процедур в машинных кодах под названием <b>Supercode</b>. Причем некоторые из предлагаемых примеров будут работать в &laquo;тандеме&raquo; с программами на Бейсике.
<p><br>
<h3><a name="n04">ОРГАНИЗАЦИЯ ПАМЯТИ</a></h3>
<hr>
При создании программ на ассемблере вы в той или иной степени лишаетесь опеки операционной системы и вынуждены самостоятельно следить за размещением в памяти кодов программы, переменных, массивов и различных рабочих областей, ежели таковые потребуются. Отчасти подобные проблемы уже могли вставать перед вами, если в своих программах на Бейсике вы использовали дополнительные шрифты или процедуры из пакетов Supercode и NewSupercode. Но в Бейсике задача по размещению кодов решается довольно просто&nbsp;- нужно только опустить <tt>RAMTOP</tt> чуть ниже адреса загрузки кодового блока, выполнив оператор <tt>CLEAR</tt>. Когда же вы начнете программировать на ассемблере, то во многих случаях этого окажется недостаточно. Поэтому необходимо четко представлять, как распределяется память между различными областями, а также какие области памяти вообще существуют и для чего они предназначены. Не обойтись и без знания строения некоторых из них. Например, для успешной обработки изображений (скажем, вывода спрайтов, скроллинга окон и&nbsp;т.&nbsp;п.) нужно уметь по координатам экрана быстро определять адрес соответствующего байта в видеобуфере. Именно этим вопросам и будет посвящен данный раздел. Не вдаваясь в подробности сразу скажем, что описываемое здесь распределение памяти будет одинаково и для стандартной конфигурации Speccy с 48 килобайтами оперативной памяти, и для ZX&nbsp;Spectrum&nbsp;128 со 128К, и даже для таких монстров, у которых ОЗУ занимает 256 или 512К.
<p><br>
<h4><a name="n04-1">ПЗУ и ОЗУ</a></h4>
Вся память компьютера делится на две основные области: постоянное запоминающее устройство (ПЗУ) и оперативная память (ОЗУ). ПЗУ начинается с адреса 0 и содержит коды операционной системы Бейсик. В&nbsp;этой области памяти ничего нельзя изменить, все, что там записано, сохраняется и при выключенном питании компьютера. Тем не менее, в ПЗУ имеется множество полезных подпрограмм, которыми мы в дальнейшем будем пользоваться с большим успехом, кроме того, мы часто будем обращаться к кодам <i>знакогенератора</i>, расположенным в самых последних ячейках ПЗУ, начиная с адреса 15616, и представляющим собой полный набор символов, печатаемых на экране. Простирается постоянная память вплоть до адреса 16384, с которого начинается область ОЗУ (рис.&nbsp;2.1).
<p>
<center><table border=0 cellspacing=0 cellpadding=0>
<tr><td><hr></td><td><hr></td><td>65535</td></tr>
<tr><td rowspan=25>ОЗУ&nbsp;&nbsp;&nbsp;&nbsp;</td><td>Определяемые пользователем символы</td></tr>
<tr><td><hr></td><td>UDG (23675)</td></tr>
<tr><td>Вершина машинного стека</td></tr>
<tr><td><hr></td><td>RAMTOP (23730)</td></tr>
<tr><td>Машинный стек</td></tr>
<tr><td><hr></td><td></td></tr>
<tr><td>Свободная память</td></tr>
<tr><td><hr></td><td>STKEND (23653)</td></tr>
<tr><td>Рабочие области Бейсика</td></tr>
<tr><td><hr></td><td>STKBOT (23651)</td></tr>
<tr><td>Стек калькулятора</td></tr>
<tr><td><hr></td><td>WORKSP (23649)</td></tr>
<tr><td>Область редактирования строк<br>бейсик-программ</td></tr>
<tr><td><hr></td><td>ELINE (23641)</td></tr>
<tr><td>Переменные Бейсика</td></tr>
<tr><td><hr></td><td>VARS (23627)</td></tr>
<tr><td>Текст бейсик-программы</td></tr>
<tr><td><hr></td><td>PROG (23635)</td></tr>
<tr><td>Канальная информация</td></tr>
<tr><td><hr></td><td>CHANS (23631)</td></tr>
<tr><td>Системные переменные</td></tr>
<tr><td><hr></td><td>23552</td></tr>
<tr><td>Буфер принтера</td></tr>
<tr><td><hr></td><td>23296</td></tr>
<tr><td>Видеобуфер</td></tr>
<tr><td><hr></td><td><hr></td><td>16384</td></tr>
<tr><td rowspan=3>ПЗУ&nbsp;&nbsp;&nbsp;&nbsp;</td><td>Знакогенератор</td></tr>
<tr><td><hr></td><td>15616</td></tr>
<tr><td>Операционная система Бейсик</td></tr>
<tr><td><hr></td><td><hr></td><td>0</td></tr>
</table><p>
<i>Рис. 2.1. Распределение областей памяти</i></center>
<p>
Если в ПЗУ все уже предопределено, то оперативная память служит для временного хранения и обработки информации. Это могут быть различные программы на Бейсике или в машинных кодах, текстовые файлы, блоки данных и&nbsp;т.&nbsp;п. Все программы, которые приведены в книге, должны размещаться именно в оперативной памяти.
<p>
Для успешного программирования в машинных кодах и на ассемблере нужно четко представлять, какие области оперативной памяти для каких целей служат. Наиболее важной из них является видеобуфер, так как никакими программными средствами невозможно изменить его местоположение, размер или строение. Экранная память начинается с адреса 16384 и занимает 6912&nbsp;байт. Вся остальная память, с адреса 23296 и до&nbsp;65535 включительно, находится в вашем безраздельном распоряжении. Правда, это только в том случае, если вы создаете программу, полностью независимую от операционной системы компьютера. Но пока программа не заблокирует систему, вы не можете нарушать содержимого и структуры некоторых областей, о назначении и расположении которых вы должны быть хорошо осведомлены, начиная программировать на ассемблере.
<p><br>
<h4><a name="n04-2">Системные области</a></h4>
Сразу за видеобуфером следует небольшая область памяти, называемая буфером принтера. Она используется только при работе с различными печатающими устройствами, поэтому если вы не предполагаете в своей программе делать какие-то распечатки на бумаге, смело можете занимать память в диапазоне адресов от&nbsp;23296 до&nbsp;23551 включительно (то есть 256&nbsp;байт) под любые нужды. Во всяком случае, буфер принтера может использоваться для временного хранения информации или как рабочий массив.
<p>
Однако нужно помнить, что все сказанное о буфере принтера справедливо лишь для стандартной конфигурации компьютера, то есть для ZX&nbsp;Spectrum&nbsp;48. Если вы пишете программы, которые должны работать на модели Spectrum&nbsp;128 или Scorpion&nbsp;ZS&nbsp;256, то столь произвольно обращаться с этой областью памяти нельзя, потому как в данных адресах указанные модели содержат жизненно важную информацию, при разрушении которой компьютер не сможет нормально продолжать работу (хотя, разумеется, можно выполнить программу и в режиме &laquo;эмуляции&raquo; обычного Speccy&nbsp;- <i>Примеч.&nbsp;ред.</i>).
<p>
С адреса 23552 начинается наиболее важная из системных областей. Вы уже частично (а&nbsp;может быть, и полностью) знакомы с системными переменными Бейсика. В&nbsp;различных ячейках этой области хранится различная информация о текущем состоянии всех без исключения параметров операционной системы, в том числе и информация о расположении всех прочих областей памяти, которые не имеют жесткой привязки к конкретным адресам (описание всех системных переменных Spectrum-Бейсика, а также ZX&nbsp;Spectrum&nbsp;128 и TR-DOS можно найти в&nbsp;[2]).
<p>
Системная переменная <tt>CHANS</tt>, находящаяся в ячейках 23631 и 23632, адресует область канальной информации, содержащей необходимые сведения о расположении процедур ввода/вывода (напоминаем, что на первом месте стоит младший байт адреса и для перевода двухбайтового значения в число требуется содержимое старшего байта умножить на&nbsp;256 и прибавить к нему число из младшего байта; например, для определения значения переменной <tt>CHANS</tt> нужно выполнить команду <tt>PRINT PEEK 23631+256*PEEK 23632</tt>). Далее следует область, хранящая текст бейсик-программы. Ее начальный адрес содержит переменная <tt>PROG</tt> (23635/23636). Сразу за бейсик-программой располагаются переменные Бейсика. Их начало можно определить, прочитав значение системной переменной <tt>VARS</tt> по адресу 23627/23628. После переменных Бейсика расположена область, предназначенная для ввода и редактирования строк бейсик-программ. Ее адрес записан в системной переменной <tt>E_LINE</tt> (23461/23642). За областью редактирования строк находится рабочая область Бейсика <tt>WORKSP</tt> (23649/23650), предназначенная для самых разных нужд. Сюда, например, считываются заголовки файлов при загрузке программ с ленты, там же размещаются строки загружаемой оператором <tt>MERGE</tt> программы до объединения их со строками программы в памяти и&nbsp;т.&nbsp;д.
<p>
Следом за областью <tt>WORKSP</tt> расположена весьма важная область, называемая <i>стеком калькулятора</i>. Название говорит само за себя: сюда записываются числовые значения, над которыми производятся различные математические операции, здесь же остается до востребования и результат расчетов. В&nbsp;дальнейшем мы не раз будем прибегать к помощи этой области, так как многие процедуры операционной системы, которыми мы будем пользоваться, берут параметры именно отсюда. Системная переменная <tt>STKBOT</tt> (23651/23652) указывает на начало стека калькулятора, а <tt>STKEND</tt> (23653/23654)&nbsp;- на его вершину. Иногда бывает важно учитывать, что каждое значение, заносимое на вершину стека калькулятора, имеет длину 5&nbsp;байт.
<p>
Системная переменная <tt>RAMTOP</tt> (23730/23731) указывает на местоположение в памяти еще одной важной области&nbsp;- <i>машинного стека</i> (не путайте со стеком калькулятора!). Но надо помнить, что в ассемблерных программах стек вполне может потерять всякую связь с <tt>RAMTOP</tt>, ибо он не является неотъемлемой частью бейсик-системы, а скорее уж, находится в &laquo;собственности&raquo; микропроцессора. Вообще же стек&nbsp;- это удивительно удобная штука для временного хранения различной информации, потому как при его использовании не приходится запоминать, где, по какому адресу или в какой переменной находится то или иное число. Важно лишь соблюсти очередность обмена данными, а чтобы не нарушить установленный порядок, следует знать, по какому принципу работает стек. Этот принцип часто называют &laquo;Last In, First Out&raquo; (LIFO), что значит &laquo;Последним вошел, первым вышел&raquo;. Совсем как в автобусе в час пик&nbsp;- чтобы выпустить какого-нибудь пассажира, прежде должны выйти все вошедшие за ним. Поэтому данные, которые понадобятся в первую очередь нужно заносить в стек последними (это же, кстати, в полной мере относится и к порядку обмена данными со стеком калькулятора).
<p>
Говоря о машинном стеке, нужно отметить один довольно интересный факт. В&nbsp;отличие от способа организации других областей памяти (а&nbsp;также и от стека калькулятора) он растет &laquo;головой вниз&raquo;, то есть каждое следующее значение, отправленное в стек, будет располагаться по адресу на 2&nbsp;байта ниже предыдущего (машинный стек работает только с двухбайтовыми величинами). Поэтому вас не должны вводить в заблуждение такие выражения как &laquo;Положить значение на вершину стека&raquo; или &laquo;Снять значение с вершины стека&raquo;&nbsp;- эта самая &laquo;вершина&raquo; всегда будет не выше основания.
<p>
Существуют и другие области памяти, как то: <tt>UDG</tt>, системные переменные TR-DOS или карта микродрайва. Область определяемых пользователем символов <tt>UDG</tt> мы рассмотрим в следующих главах, а о других разделах памяти (в том числе и об архитектуре Spectrum&nbsp;128) вы можете получить дополнительные сведения, например, в книге&nbsp;[2].
<p><br>
<h4><a name="n04-3">Строение экрана</a></h4>
Как мы уже говорили, важность знания структуры экранной области трудно переоценить. Умение быстро рассчитывать адрес в видеобуфере по координатам экрана понадобится нам в большинстве графических построений, особенно, если вы хотите научиться обходиться без опеки операционной системы, которая почти всегда оказывается не достаточно быстродействующей.
<p>
Строение экрана &laquo;на высоком уровне&raquo; вам уже должно быть известно (рис.&nbsp;2.2), но тем не менее, напомним, из каких частей он состоит. Внешняя область, называемая <i>бордюром</i>, может только изменять свой цвет, никакую графическую информацию, за исключением быстро бегущих по нему полос, в эту область поместить невозможно. Внутри бордюра находится <i>рабочий экран</i>, сюда может быть выведена любая текстовая или графическая информация. Говоря об экране, мы всегда будем подразумевать именно эту его часть. Рабочий экран в свою очередь делится на <i>основной экран</i> и <i>служебное окно</i>, которое обычно занимает две нижние строки, но в некоторых случаях может увеличиваться или уменьшаться. Всего экран имеет 24&nbsp;текстовые строки, и в каждой строке можно напечатать 32&nbsp;символа. Эти стандартные площадки для вывода символов называются <i>знакоместами</i>. Любое изображение на экране состоит из маленьких квадратиков, называемых <i>пикселями</i>, и каждое знакоместо имеет размеры 8&nbsp;<font face="symbol">ґ</font>&nbsp;8 таких элементарных &laquo;точек&raquo;.
<p>
<center>
<IMG SRC="pic\scr.gif"><p>
<i>Рис. 2.2. Строение экрана</i></center>
<p>
Теперь перейдем к более низкому уровню и посмотрим, как адресуется область видеобуфера. Вы, наверное, не раз наблюдали, как грузятся с магнитофона стандартные экранные файлы: область экрана заполняется не последовательно, строка за строкой, а довольно хитрым способом. Сначала один за другим появляются верхние ряды пикселей восьми первых текстовых строк, затем в этих же строках рисуются все вторые ряды и так далее, пока не сформируется изображение всей верхней трети экрана. Затем, в том же порядке, заполняется средняя часть экрана, а потом и нижняя. И&nbsp;только в самом конце последовательно выводятся атрибуты всех знакомест. Однако это говорит не о каком-то изощренном способе загрузки именно экранных файлов&nbsp;- они грузятся так же, как и любые другие, последовательно заполняя ячейки памяти от младших адресов к старшим. Это свидетельствует, напротив, о нелинейном строении экранной области памяти.
<p>
На первый взгляд такая организация экранной области кажется исключительно неудобной, особенно при решении задач определения адреса по заданным координатам. Но это лишь до тех пор, пока вы используете в расчетах только десятичные числа. Ведь даже начальный адрес видеобуфера 16384 в десятичном виде представляется просто &laquo;взятым с потолка&raquo;. В&nbsp;таких случаях гораздо удобнее пользоваться несколько иным представлением числовой информации. Мы имеем в виду шестнадцатеричный формат чисел, который от десятичного отличается &laquo;емкостью&raquo; разрядов.
<p>
В десятичном представлении каждый разряд числа может изменяться от&nbsp;0 до&nbsp;9, а в шестнадцатеричном&nbsp;- от&nbsp;0 до&nbsp;15. Цифры от&nbsp;0 до&nbsp;9 при этом записываются так же, как и в десятичных числах, а дальше применяются буквы латинского алфавита от&nbsp;A до&nbsp;F. Вот соответствие чисел в десятичном и шестнадцатеричном форматах:
<pre>
0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18...
0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F 10 11 12...
</pre>
Если адрес 16384 привести к шестнадцатеричному виду, то он вдруг окажется совершенно &laquo;ровным&raquo;&nbsp;- #4000 (знак <b>#</b> перед числом говорит о том, что оно представлено как шестнадцатеричное). Взгляните на схему, изображенную на рис.&nbsp;2.3 и вы заметите явную закономерность в распределении адресного пространства видеообласти. В&nbsp;недалеком будущем мы подробно расскажем о методах вычисления адресов экрана, а сейчас перейдем к рассмотрению других не менее важных понятий.
<p>
<a name="p03"></a>
<center>
<table border=0>
<tr align=center><td>&nbsp;Данные&nbsp;</td><td>&nbsp;Атриб.&nbsp;</td><td>&nbsp;Строка&nbsp;</td><td>&nbsp;ВИДЕОБУФЕР&nbsp;</td><td>&nbsp;Строка&nbsp;</td><td>&nbsp;Данные&nbsp;</td><td>&nbsp;Атриб.&nbsp;</td></tr>
<tr align=center><td>#4000</td><td>#5800</td><td>0</td><td><hr></td><td>0</td><td>#401F</td><td>#581F</td></tr>
<tr align=center><td>#4020</td><td>#5820</td><td>1</td><td><hr></td><td>1</td><td>#403F</td><td>#583F</td></tr>
<tr align=center><td>#4040</td><td>#5840</td><td>2</td><td><hr></td><td>2</td><td>#405F</td><td>#585F</td></tr>
<tr align=center><td>#4060</td><td>#5860</td><td>3</td><td><hr></td><td>3</td><td>#407F</td><td>#587F</td></tr>
<tr align=center><td>#4080</td><td>#5880</td><td>4</td><td><hr></td><td>4</td><td>#409F</td><td>#589F</td></tr>
<tr align=center><td>#40A0</td><td>#58A0</td><td>5</td><td><hr></td><td>5</td><td>#40BF</td><td>#58BF</td></tr>
<tr align=center><td>#40C0</td><td>#58C0</td><td>6</td><td><hr></td><td>6</td><td>#40DF</td><td>#58DF</td></tr>
<tr align=center><td>#40E0</td><td>#58E0</td><td>7</td><td><hr></td><td>7</td><td>#40FF</td><td>#58FF</td></tr>
<tr align=center><td>#4800</td><td>#5900</td><td>8</td><td><hr></td><td>8</td><td>#481F</td><td>#591F</td></tr>
<tr align=center><td>#4820</td><td>#5920</td><td>9</td><td><hr></td><td>9</td><td>#483F</td><td>#593F</td></tr>
<tr align=center><td>#4840</td><td>#5940</td><td>10</td><td><hr></td><td>10</td><td>#485F</td><td>#595F</td></tr>
<tr align=center><td>#4860</td><td>#5960</td><td>11</td><td><hr></td><td>11</td><td>#487F</td><td>#597F</td></tr>
<tr align=center><td>#4880</td><td>#5980</td><td>12</td><td><hr></td><td>12</td><td>#489F</td><td>#599F</td></tr>
<tr align=center><td>#48A0</td><td>#59A0</td><td>13</td><td><hr></td><td>13</td><td>#48BF</td><td>#59BF</td></tr>
<tr align=center><td>#48C0</td><td>#59C0</td><td>14</td><td><hr></td><td>14</td><td>#48DF</td><td>#59DF</td></tr>
<tr align=center><td>#48E0</td><td>#59E0</td><td>15</td><td><hr></td><td>15</td><td>#48FF</td><td>#59FF</td></tr>
<tr align=center><td>#5000</td><td>#5A00</td><td>16</td><td><hr></td><td>16</td><td>#501F</td><td>#5A1F</td></tr>
<tr align=center><td>#5020</td><td>#5A20</td><td>17</td><td><hr></td><td>17</td><td>#503F</td><td>#5A3F</td></tr>
<tr align=center><td>#5040</td><td>#5A40</td><td>18</td><td><hr></td><td>18</td><td>#505F</td><td>#5A5F</td></tr>
<tr align=center><td>#5060</td><td>#5A60</td><td>19</td><td><hr></td><td>19</td><td>#507F</td><td>#5A7F</td></tr>
<tr align=center><td>#5080</td><td>#5A80</td><td>20</td><td><hr></td><td>20</td><td>#509F</td><td>#5A9F</td></tr>
<tr align=center><td>#50A0</td><td>#5AA0</td><td>21</td><td><hr></td><td>21</td><td>#50BF</td><td>#5ABF</td></tr>
<tr align=center><td>#50C0</td><td>#5AC0</td><td>22</td><td><hr></td><td>22</td><td>#50DF</td><td>#5ADF</td></tr>
<tr align=center><td>#50E0</td><td>#5AE0</td><td>23</td><td><hr></td><td>23</td><td>#50FF</td><td>#5AFF</td></tr>
</table>
<i>Рис. 2.3. Адресация видеобуфера</i></center>

<p><br>
<h3><a name="n05">РЕГИСТРЫ И РЕГИСТРОВЫЕ ПАРЫ</a></h3>
<hr>
Для общения с компьютером на уровне машинных кодов необходимо усвоить еще одно новое понятие кроме таких, как память, адрес, байт, бит, с которыми, надеемся, вы уже достаточно неплохо разобрались. Речь идет о <i>регистрах</i> микропроцессора. Регистры можно представить как совершенно особые внутренние ячейки памяти, являющиеся неотъемлемой частью центрального процессора. Роль их настолько важна, что практически ни одна операция не обходится без участия регистров, а различные арифметические и логические действия без них и вовсе невозможны.
<p>
Мы назвали регистры особыми ячейками, но в чем же их особенность и чем они отличаются от ячеек обычной оперативной памяти? В&nbsp;первую очередь их особенность проявляется в том, что регистры не равноценны, то есть действия, допустимые с использованием одного регистра невозможны с другими и наоборот. Кроме того, если значения одних регистров можно изменять непосредственно, записывая в них те или иные числа, то другие изменяются автоматически, и узнать их содержимое возможно только лишь косвенными методами.
<p>
Другая особенность регистров состоит в том, что для обращения к ним используются не адреса, а собственные имена, состоящие из одной или двух букв латинского алфавита (конечно же, имена присутствуют только в языке ассемблера, а не в машинных кодах команд).
<p>
Есть и еще одно свойство, отличающее регистры от ячеек памяти&nbsp;- это способность их объединяться определенным образом, составляя <i>регистровые пары</i>. Во всем же остальном они очень схожи с отдельными ячейками памяти компьютера. Они также имеют размер байта (8&nbsp;бит), в них можно записывать числа и читать их значение (за исключением системных регистров), информация в них может сохраняться, как и в памяти, до тех пор, пока не будет изменена программой.
<p>
Все регистры могут быть подразделены на несколько групп, учитывая характер функций, которые они выполняют. Начнем с самой многочисленной и наиболее важной группы&nbsp;- с так называемых <i>регистров общего назначения</i> или <i>регистров данных</i>. Их насчитывается семь: A, B, C, D, E, H и L. Как уже говорилось, каждый регистр может использоваться лишь в строго определенных операциях и каждый из них в этом смысле уникален. Например, регистр&nbsp;A (часто называемый аккумулятором) участвует во всех арифметических и логических операциях, результат которых мы получаем в том же регистре&nbsp;A. Использование регистра&nbsp;B наиболее удобно при организации циклов. При этом он выполняет роль, схожую с обязанностями управляющих переменных циклов <tt>FOR...NEXT</tt> в Бейсике. Другие регистры проявляют свою индивидуальность, преимущественно, объединившись в пары. Возможны следующие регистровые пары: BC, DE и HL. И&nbsp;вам следует запомнить, что никаких других вариантов соединения регистров не существует.
<p>
Из сказанного может создаться впечатление, что аккумулятор остался в одиночестве, не найдя своей половинки. Однако это не совсем так. На самом деле существует пара и для него. Просто пока мы сознательно умалчиваем об этом, так как регистр, дополняющий аккумулятор до пары, имеет совершенно особый статус и заслуживает отдельного разговора, который мы поведем в разделе <a href="wgasm05.htm#n01" target="view">&laquo;Организация циклов в ассемблере&raquo;</a> главы&nbsp;5.
<p>
Каждая из регистровых пар так же, как и любой из отдельных регистров, выполняет вполне конкретные, возложенные именно на нее функции. Так пара BC часто используется, подобно регистру&nbsp;B в качестве счетчика в циклах. HL несет наибольшую нагрузку, играя примерно ту же роль, что и аккумулятор: только с этой парой можно выполнять арифметические действия. Пара DE зачастую адресует пункт назначения при перемещениях данных из одной области памяти в другую.
<p>
Работая с регистровыми парами, приходится иметь дело с двухбайтовыми величинами. Поэтому необходимо четко представлять, как такие числа хранятся в памяти и каким образом они размещаются на регистрах. В&nbsp;Бейсике вам, вероятно, уже доводилось сталкиваться с подобной задачей. Если вы пользовались оператором <tt>POKE</tt> и функцией <tt>PEEK</tt>, например, для изменения или чтения системных переменных, то вам уже должно быть известно, что двухбайтовые значения хранятся в памяти, как правило, в обратном порядке&nbsp;- сначала младший байт, затем старший. Это можно продемонстрировать на таких примерах: число&nbsp;1 запишется в памяти в виде последовательности байтов&nbsp;1 и&nbsp;0; у числа&nbsp;255 старшая часть также равна нулю, поэтому оно будет представлено как 255 и&nbsp;0; следующее число&nbsp;256, расположившись в двух ячейках, будет выглядеть как 0 и&nbsp;1. На всякий случай напомним вам способ, позволяющий разложить любое число из диапазона 0...65535 на два байта и определить значения старшей и младшей половинки:
<pre>
LET high= INT(N/256): REM Старшая часть
LET low=N-256*high: REM Младшая часть
</pre>
Вам также часто придется сталкиваться с необходимостью изменять только старший или только младший регистр в регистровых парах. Поэтому следует хорошенько запомнить правило, которому подчиняются регистры при объединении. Оказывается, порядок здесь прямо противоположный по сравнению с числами в памяти&nbsp;- первым записывается старший регистр, а за ним младший. То есть в паре BC старшим окажется регистр&nbsp;B, в DE&nbsp;- D, а в HL&nbsp;- H. Чтобы лучше запомнить это, можете представить имя регистровой пары HL как сокращения английских слов HIGH (высокий, старший) и LOW (низкий, младший), а то, что порядок следования старшей и младшей половинок в остальных парах аналогичен, это уже само собой разумеется.
<p>
К следующей группе относятся два индексных регистра, имена которых начинаются с буквы I (Index)&nbsp;- IX и IY. В&nbsp;отличие от регистров данных, индексные регистры состоят из 16 разрядов, то есть являются как бы неделимыми регистровыми парами. (На самом деле существуют методы разделения индексных регистров на 8-разрядные половинки, что уже относится к программистским изощрениям. Об этих методах вы можете узнать из <a href="append02.htm#n00" target="view">Приложения&nbsp;II</a>.) В&nbsp;основном они применяются при обработке блоков данных, массивов или разного рода таблиц, но также вполне могут использоваться и как обычные регистры общего назначения. Удобство употребления этих регистров заключается в том, что они позволяют обратиться к любому элементу массива или таблицы без изменения содержимого самого регистра, а лишь указанием величины смещения для данного элемента (иначе, его номера или индекса, например, IX+5). Заметим, что регистр&nbsp;IY обычно адресует область системных переменных Бейсика и поэтому отчасти и только в компьютерах ZX&nbsp;Spectrum может быть отнесен к следующей группе&nbsp;- системным регистрам.
<p>
К системным или иначе&nbsp;- аппаратным регистрам относятся: указатель вершины стека SP (Stack Point), вектор прерываний I (Interrupt) (точнее, этот регистр содержит старший байт адреса векторов прерываний; позднее мы подробно расшифруем это понятие) и регистр регенерации R. Первый из них, так же, как и индексные регистры, имеет 16&nbsp;разрядов, разделить которые на 8-битовые половинки нет никакой возможности. Но это и не нужно, ведь регистр SP служит для вполне определенных целей&nbsp;- указывает адрес вершины области машинного стека, как это и следует из его названия. Хотя с ним и можно обращаться, как с обычным регистром данных (записывать или читать из него информацию), но делать это нужно, совершенно точно представляя, что при этом происходит. Обычно же за регистром SP следит микропроцессор и изменяет его так, как надо при выполнении некоторых команд. Например, без этого регистра оказались бы совершенно невозможны вызовы подпрограмм с нормальным возвратом из них в основную программу.
<p>
Регистры I и R, в противоположность всем прочим, никогда не объединяются в пары и существуют только по отдельности. Содержимое вектора прерываний I также может быть изменено программным путем, однако делать этого не стоит до тех пор, пока вы не разберетесь с таким достаточно сложным вопросом, как прерывания. Что же касается регистра R, то читать из него можно, а вот записывать в него информацию в большинстве случаев бесполезно, так как он изменяется аппаратно. Правда, используется для аппаратных нужд только 7&nbsp;младших разрядов, так что, если вам для чего-то окажется достаточно одного бита, можете хранить его в старшем разряде регистра регенерации.
<p>
В свое время мы подробно расскажем о применении всех существующих регистров, а сейчас закончим этот краткий обзор и займемся другими вопросами.
<p><br>
<h3><a name="n06">ПРОСТЕЙШАЯ ПРОГРАММА В МАШИННЫХ КОДАХ</a></h3>
<hr>
Как мы уже говорили, ассемблер невысоко поднялся над машинным языком, поэтому, прежде чем бросаться с головой в программирование, будет полезно составить хотя бы несколько коротеньких программок чисто в машинных кодах. Это позволит гораздо лучше прочувствовать идеологию ассемблера и понять, как работает микропроцессор.
<p>
Большинство программ на машинном языке, имеющих возврат в Бейсик, заканчивается кодом&nbsp;201 (в&nbsp;мнемоническом обозначении&nbsp;- RET), который аналогичен оператору <tt>RETURN</tt>. Поэтому простейшая программа может состоять всего из одного байта. Давайте сейчас создадим такую программу, а потом и выполним ее. Введите с клавиатуры оператор
<pre>
POKE 40000,201
</pre>
а затем, чтобы проверить действие полученной &laquo;программы&raquo;, запустите ее с помощью функции <tt>USR</tt>, например, так:
<pre>
RANDOMIZE USR 40000
</pre>
Вроде бы ничего особенного не произошло&nbsp;- никаких видимых или слышимых эффектов. Но, по крайней мере, ваш компьютер выдержал подобное испытание и при этом не &laquo;завис&raquo; и не &laquo;сбросился&raquo; (если он исправен, конечно, на что мы надеемся). Программа нормально завершила свою работу и благополучно вышла в Бейсик с сообщением <tt>0 OK</tt>.
<p>
Теперь попробуем запустить ее несколько иным способом. Заменим оператор <tt>RANDOMIZE</tt> на <tt>PRINT</tt>:
<pre>
PRINT USR 40000
</pre>
То, что вы увидели на экране&nbsp;- весьма существенно и может очень пригодиться в будущем. Компьютер напечатал то же самое число, которое мы использовали в качестве аргумента функции <tt>USR</tt>. Можете проверить, что это не случайное совпадение, введя строку
<pre>
POKE 40001,201: PRINT USR 40001
</pre>
Можете попробовать проделать то же самое и с другими адресами, только не слишком увлекайтесь, чтобы не залезть в &laquo;запрещенные&raquo; области памяти. Для подобных экспериментов лучше не выходить из диапазона адресов от 30000 до 60000, да и то лишь в том случае, если память компьютера свободна от каких-либо других программ.
<p>
Для того, чтобы каким-то образом использовать полученный результат, необходимо понять причину такого странного поведения компьютера. Ответ на эту загадку заключается в том, что <tt>USR</tt>&nbsp;- это функция, а любая функция, по своему определению, должна получать что-то на входе и возвращать нечто на выходе. Поэтому остается лишь выяснить сущность этих &laquo;что-то&raquo; и &laquo;нечто&raquo;&nbsp;- и вопрос можно считать решенным.
<p>
Как вы увидите позже, большинство процедур в машинных кодах, если это необходимо, получают входные параметры и возвращают значения на регистрах. Как правило, это оказывается наиболее удобно. Поскольку функция <tt>USR</tt> предназначена для вызова машинных процедур, то и она может обмениваться числовыми данными с программой на Бейсике также через регистры, а именно&nbsp;- через регистровую пару BC. В&nbsp;качестве входного параметра используется аргумент функции, а на выходе значение пары BC передается бейсик-программе. А&nbsp;так как в приведенных выше примерах никакие регистры не изменялись, то и на экране появлялось то же самое число, которое использовалось в качестве аргумента.
<p>
Теперь модернизируем нашу программку так, чтобы содержимое регистровой пары BC изменялось. Можно, например, просто записать в нее какое-нибудь число. Обычно запись в регистры числовых значений называют загрузкой, поэтому в мнемоническом обозначении такие команды начинаются с LD (сокращение от известного вам по Бейсику слова LOAD&nbsp;- загрузить). А&nbsp;выражение &laquo;загрузить регистровую пару BC значением 1000&raquo; записывается как
<pre>
       LD    BC,1000
</pre>
Эта команда всегда состоит из трех байт: первый равен 1, а второй и третий соответствуют двухбайтовому представлению числа в памяти. Таким образом, программа из двух команд
<pre>
       LD    BC,1000
       RET
</pre>
в памяти будет представлена последовательностью кодов
<pre>
1, 232, 3 и 201
</pre>
Введите их последовательно, начиная, например, с адреса 60000 и выполните закодированную программку оператором
<pre>
PRINT USR 60000
</pre>
Если вы ничего не напутали, то на экране должно появиться число 1000.
<p>
Надо думать, на этих примерах вы уже почувствовали &laquo;прелесть&raquo; программирования в машинных кодах и догадались, что подобным методом может пользоваться только сумасшедший или неукротимый фанатик. Однако и фанатик в конце концов понимает, что лучше все же воспользоваться ассемблером, благо фирма HISOFT подарила синклеристам весьма недурную реализацию этого языка, по многим параметрам могущую считаться вполне профессиональной. (Лучшей реализацией языка ассемблера для компьютеров семейства ZX&nbsp;Spectrum считается транслятор фирмы OCEAN Software из пакета Laser Genius, однако ассемблер фирмы HISOFT остается непревзойденным по минимальному объему занимаемой самим транслятором памяти и, соответственно, максимальному размеру области, отводимой для создаваемого им кода программы. Как и Бейсик&nbsp;48, этот ассемблер использует несколько усеченный строчный текстовый редактор. Это, конечно, немного хуже, чем экранный редактор (как, например, в Бейсике&nbsp;128), но за все приходится чем-то расплачиваться&nbsp;- <i>Примеч.&nbsp;ред.</i>)
<p>

<hr>

<center><table border=0 cellpadding=24>
<tr><td>
<a href="wgasm01.htm#n00"><img src="prev.gif" border=0 hspace=8>Глава 1</a></td>
<a href="wgasm03.htm#n00">Глава 3<img src="next.gif" border=0 hspace=8></a>
</td></tr>
</table></center>
<center><a href="wgasmtoc.htm#n00">Оглавление</a></center>

<hr>

</BODY>
</HTML>
